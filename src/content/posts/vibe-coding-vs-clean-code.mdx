---
title: "Vibe Coding vs. Clean Code"
excerpt: "C√≥mo redise√±√© mi portfolio con IA (v0 y Next.js) sin que la deuda t√©cnica me comiera vivo."
date: "2026-01-17"
readingTime: "3 min"
tags: ["Vibe Coding", "Next.js", "Clean Code", "IA"]
featured: true
---
En los √∫ltimos a√±os, mi filosof√≠a de desarrollo se ha basado en 3 pilares: **Clean Code**, **TDD** (Test Driven Development) y **Arquitectura Evolutiva**. Para m√≠, el c√≥digo no es solo un conjunto de instrucciones para una m√°quina; es contenido t√©cnico que debe ser legible, mantenible y robusto, una documentaci√≥n viva.

Sin embargo, para el reciente redise√±o de mi web personal, decid√≠ hacer algo que, sobre el papel, va en contra de mis instintos: abrazar el **"Vibe Coding"**.

Si no has o√≠do el t√©rmino, el *Vibe Coding* es esa tendencia reciente de iterar software a velocidad de v√©rtigo usando IAs generativas, priorizando el resultado visual y la funcionalidad inmediata sobre la implementaci√≥n subyacente. B√°sicamente: *"Si funciona y se ve bien, tira millas"*.

¬øPuede un Software Crafter sobrevivir a esto sin perder su alma (y la calidad de su c√≥digo) en el proceso? **Spoiler: S√≠, pero con matices.**

## El problema: La par√°lisis del tiempo

Mi web anterior estaba construida en Astro. Era bastante r√°pida y me hab√≠a preocupado por la calidad del c√≥digo. Pero visualmente... bueno, digamos que necesitaba una renovaci√≥n y no pod√≠a dedicarle mucho tiempo.

Cada vez que quer√≠a cambiar el dise√±o, me encontraba peleando con CSS Grid, alineaciones y paletas de colores. Esa fricci√≥n hac√≠a que pospusiera las actualizaciones indefinidamente. Ten√≠a par√°lisis por an√°lisis (y por CSS).

Necesitaba un cambio de enfoque. Necesitaba velocidad para romper el folio en blanco.

## El Stack del experimento

Decid√≠ probar un flujo de trabajo "AI-First":

* **El Motor:** Migraci√≥n de Astro a **Next.js**. ¬øPor qu√©? Porque la integraci√≥n con las herramientas de IA actuales es mucho m√°s fluida en el ecosistema React.
* **El Artista:** **v0 (de Vercel)** para generar la interfaz de usuario (UI).
* **El Copiloto:** **Gemini** y **Claude** para la l√≥gica, textos y refactorizaci√≥n.

## La fase de "Vibe Coding": Magia y Caos

Empec√© pidi√©ndole a Gemini que me ayudara a hacer los prompts para v0, algo espec√≠fico: *"Un portfolio estilo Bento Grid, oscuro, con acentos naranjas, tipograf√≠a t√©cnica. Que parezca el IDE de un desarrollador."*

En menos de 60 segundos, ten√≠a una interfaz visualmente impactante. Algo que a m√≠, picando c√≥digo a mano, me habr√≠a llevado un fin de semana entero maquetar. **La sensaci√≥n de velocidad es adictiva.** Copias el componente, lo pegas en tu proyecto y *voil√†*: funciona.

Aunque para llegar a este punto tuve que iterar varias veces con los prompts, ajustando colores, tama√±os y disposici√≥n. La IA no es perfecta, pero su rapidez permite un ciclo de prueba y error muy √°gil.

## El eslab√≥n perdido: Claude como "Pair Programmer"

Aqu√≠ es donde entr√≥ la segunda pieza del puzzle. Si v0 era el dise√±ador creativo, **Claude** se convirti√≥ en el ingeniero de soporte. Su rol fue crucial para cerrar la brecha entre el prototipo y el producto final:

1.  **Limpiar los errores de v0:** A veces, v0 generaba estilos que se ve√≠an bien en desktop pero romp√≠an el responsive en m√≥vil, o usaba librer√≠as que yo no ten√≠a instaladas. En lugar de pelearme con el CSS, le ped√≠a a Claude: *"Este componente tiene scroll horizontal indeseado en m√≥vil, arr√©glalo usando clases est√°ndar de Tailwind"*.
2.  **Migraci√≥n de contenido masiva:** Ten√≠a decenas de posts y charlas en mi antigua web (en formato Astro/Markdown). Moverlos a mano a la nueva estructura de Next.js hubiera sido un dolor. Le pas√© a Claude mis archivos antiguos y los nuevos componentes de v0, y √©l se encarg√≥ de transformar y adaptar todo el contenido para que encajara en los nuevos *props* autom√°ticamente.

Pero aqu√≠ es donde termina la magia y empieza la realidad.

Al revisar el c√≥digo generado, mi "yo" desarrollador empez√≥ a ver las grietas:
* Componentes monol√≠ticos de 400 l√≠neas.
* Textos "hardcodeados" dentro del JSX.
* Mala sem√°ntica HTML (divs dentro de botones, falta de `aria-labels`).
* L√≥gica de negocio mezclada con la presentaci√≥n.

La IA me hab√≠a dado un prototipo precioso, pero estructuralmente fr√°gil.

## El retorno al Clean Code: El rol del Editor

Aqu√≠ es donde creo que reside el futuro de nuestra profesi√≥n. No se trata de rechazar la IA por "sucia", ni de aceptarla ciegamente. Se trata de **elevar el nivel de abstracci√≥n.**

Mi rol dej√≥ de ser el de "Alba√±il de C√≥digo" (escribir cada `<div>`) y pas√≥ a ser el de **Arquitecto y Editor**.

El proceso que segu√≠ fue:

1.  **Aceptaci√≥n:** Usar el c√≥digo de v0 como base visual. Me ahorr√≥ el 80% del trabajo tedioso de estilos.
2.  **Extracci√≥n y Componentizaci√≥n:** Romper ese bloque monol√≠tico en piezas reutilizables.
3.  **Tipado Fuerte:** A√±adir interfaces de TypeScript. La IA suele ser laxa con los tipos.
4.  **Separaci√≥n de Responsabilidades:** Asegurarme de que los componentes de UI sean "tontos" (solo pintan datos) y la l√≥gica viva separada.

## Un ejemplo pr√°ctico: Refactorizando el caos

Para que veas a qu√© me refiero, aqu√≠ tienes un ejemplo real. La IA me gener√≥ un componente de tarjeta visualmente perfecto, pero con este aspecto en el c√≥digo:
```tsx
// ‚ùå El c√≥digo "Vibe" (Generado por IA)
// Funciona, pero es dif√≠cil de mantener
<div className="w-full border rounded-lg p-6 bg-zinc-900">
  <div className="flex justify-between mb-4">
    <h3 className="text-xl font-bold">Lean Mind Tools</h3>
    <span className="text-green-500 text-xs">Active</span>
  </div>
  <p className="text-gray-400 text-sm">Herramientas internas...</p>
  {/* ... sopa de divs ... */}
</div>
```

Funciona, pero si quiero cambiar el dise√±o ma√±ana, sufro. Aplicando Clean Code, extraje la UI a componentes at√≥micos y defin√≠ una interfaz clara:
```tsx
// ‚úÖ El c√≥digo "Crafted" (Refactorizado)
// Robusto, reutilizable y testeable
interface ProjectCardProps {
  title: string;
  status: 'active' | 'archived';
  description: string;
  tags: string[];
}

export const ProjectCard = ({ title, status, description, tags }: ProjectCardProps) => {
  return (
    <Card className="hover:border-brand-orange">
      <CardHeader title={title} status={status} />
      <CardBody>{description}</CardBody>
      <CardFooter tags={tags} />
    </Card>
  );
};
```

El resultado visual es id√©ntico (pixel-perfect gracias a la IA), pero la arquitectura subyacente ahora es s√≥lida.

## Conclusi√≥n: Velocidad vs. Artesan√≠a
Este redise√±o me ha ense√±ado una lecci√≥n de humildad. A veces, nuestro af√°n por la perfecci√≥n t√©cnica nos frena a la hora de aportar valor (o simplemente, de lanzar cosas).

La IA me permiti√≥ romper el bloqueo del dise√±o. El Clean Code me permiti√≥ dormir tranquilo sabiendo que el proyecto es mantenible.

No creo que el "Vibe Coding" sea el enemigo del "Clean Code". Si se usa con criterio, es simplemente una herramienta m√°s en el cintur√≥n del artesano. La clave est√° en no olvidar que, al final del d√≠a, t√∫ eres el responsable de lo que llega a producci√≥n, no el prompt.

¬øTe ha gustado el nuevo dise√±o? Puedes ver el c√≥digo (ya refactorizado y limpio üòâ) en mi [GitHub](https://github.com/Sstark97/ascinfo.dev).
