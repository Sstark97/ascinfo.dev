---
title: "El dise√±o no es arte, es supervivencia: Practical Object Oriented Design (I-II)"
excerpt: "Conclusiones clave de los dos primeros cap√≠tulos de 'Practical Object-Oriented Design in Ruby' de Sandi Metz, aplicadas a C#."
date: "2026-01-23"
readingTime: "6 min"
tags: ["Arquitectura", "Practical Object Oriented Design", "Clean Code"]
featured: true
---

# El dise√±o no es arte, es supervivencia: Practical Object Oriented Design (I-II)

Si llevas un tiempo en esto del desarrollo, seguro que conoces esa sensaci√≥n: abres un proyecto, te piden un cambio "sencillo" y, de repente, te das cuenta de que para tocar una l√≠nea tienes que entender todo el sistema.

Eso es lo que pasa cuando el dise√±o falla.

Hace poco empec√© a estudiar a fondo **"Practical Object-Oriented Design in Ruby" (POODR)** de Sandi Metz. Aunque el libro usa Ruby, sus lecciones sobre arquitectura trascienden el lenguaje. Son verdades universales sobre c√≥mo gestionar dependencias.

En este post quiero destilar los aprendizajes de los dos primeros cap√≠tulos y traducir esos conceptos (y sus ejemplos de bicicletas) a **C#**.

---

## 1. El dise√±o es el arte de gestionar el cambio

Sandi Metz empieza con una verdad inc√≥moda: **Si tu aplicaci√≥n no tuviera que cambiar nunca, el dise√±o dar√≠a igual.**

Podr√≠as escribir todo en un solo archivo `Program.cs` de 5000 l√≠neas y, si compila y funciona, estar√≠a "bien". El problema es que **el cambio es inevitable**.

El dise√±o es, por tanto, un recorrido por un camino ramificado. No se trata de seguir reglas fijas, sino de tomar decisiones hoy que no te cierren puertas ma√±ana.

* **Mal dise√±o:** Los cambios peque√±os provocan efectos secundarios en cascada.
* **Buen dise√±o:** Preserva la variabilidad. Puedes cambiar de opini√≥n sin reescribir la app.

## 2. ¬øTu c√≥digo es TRUE?

Definir "c√≥digo limpio" es subjetivo. Metz nos da un acr√≥nimo concreto para evaluar si una clase es realmente f√°cil de cambiar: **TRUE**.

* **T (Transparent):** Las consecuencias de un cambio deben ser evidentes en el c√≥digo local y en el remoto.
* **R (Reasonable):** El coste del cambio es proporcional al beneficio.
* **U (Usable):** El c√≥digo debe poder reutilizarse en contextos nuevos e inesperados.
* **E (Exemplary):** El c√≥digo anima a quienes lo toquen despu√©s a perpetuar estas cualidades.

---

## 3. El Principio de Responsabilidad √önica (SRP)

La base de un sistema mantenible es que cada clase haga la menor tarea √∫til posible.

Miremos esta clase `Gear` (Engranaje). Su responsabilidad es calcular el ratio entre el plato y el pi√±√≥n.

```csharp
public class Gear
{
    public int Chainring { get; }
    public int Cog { get; }

    public Gear(int chainring, int cog)
    {
        Chainring = chainring;
        Cog = cog;
    }

    public double Ratio()
    {
        return (double)Chainring / Cog; 
    }
}
```

¬øC√≥mo sabemos si cumple SRP? Sandi sugiere interrogar a la clase:

üßë‚Äçüíª "Oye Gear, ¬øcu√°l es tu ratio?" -> ‚úÖ Tiene sentido.

üßë‚Äçüíª "Oye Gear, ¬øcu√°l es el tama√±o de tu neum√°tico?" -> ‚ùå Suena raro.

Si la clase tuviera m√©todos sobre neum√°ticos o llantas, estar√≠amos violando la cohesi√≥n. Una clase con m√∫ltiples responsabilidades es dif√≠cil de reutilizar porque, si solo quieres una parte (el ratio), te obligas a cargar con el resto (las ruedas), aumentando el riesgo de fallos.

---

## 4. El peligro de las estructuras de datos complejas
Aqu√≠ es donde m√°s fallamos en el d√≠a a d√≠a. A menudo pasamos datos "crudos" (arrays, listas de listas, JSONs parseados) por toda la aplicaci√≥n. Esto crea una dependencia brutal de la estructura de esos datos.

Imagina que recibimos una lista de datos de ruedas, donde la posici√≥n 0 es la llanta y la 1 es el neum√°tico.

### ‚ùå El enfoque acoplado (Obscuring References)

```csharp
public class ObscuringReferences
{
    private readonly List<int[]> _data;

    public ObscuringReferences(List<int[]> data)
    {
        _data = data;
    }

    public List<int> Diameters()
    {
        // ‚ö†Ô∏è PELIGRO: El 0 es la llanta, el 1 es el neum√°tico.
        // Si la estructura del array cambia, esto se rompe.
        // El c√≥digo "sabe" demasiado sobre la estructura interna.
        return _data.Select(cell => cell[0] + (cell[1] * 2)).ToList();
    }
}
```

Este c√≥digo es fr√°gil. Si el proveedor de datos cambia el orden del array, tenemos que buscar cada lugar donde hayamos escrito cell[0] y arreglarlo. Adem√°s, leer cell[1] no nos dice nada sobre qu√© representa ese dato.

### ‚úÖ El enfoque revelador (Revealing References)
La soluci√≥n es separar la estructura del significado. Convertimos esa lista cruda en objetos con nombre (usando un record de C#, por ejemplo) en cuanto entran en nuestra clase.

```csharp
public class RevealingReferences
{
    public List<Wheel> Wheels { get; }

    public RevealingReferences(List<int[]> data)
    {
        // Convertimos los datos crudos en objetos con significado al inicio
        Wheels = Wheelify(data);
    }

    public List<int> Diameters()
    {
        // Ahora el c√≥digo habla el lenguaje del dominio
        return Wheels.Select(wheel => wheel.Rim + (wheel.Tire * 2)).ToList();
    }

    private List<Wheel> Wheelify(List<int[]> data)
    {
        return data.Select(cell => new Wheel(cell[0], cell[1])).ToList();
    }
    
    // Un simple record nos da sem√°ntica y protecci√≥n
    private record Wheel(int Rim, int Tire);
}
```

Ahora, si la estructura del array cambia, solo tenemos un punto de fallo: el m√©todo `Wheelify`. El resto de la aplicaci√≥n est√° protegida y es mucho m√°s legible.

---

## Conclusi√≥n: Dise√±a para el futuro, codifica para el presente
La lecci√≥n m√°s importante de estos primeros cap√≠tulos es sobre cu√°ndo tomar decisiones.

A menudo sentimos la presi√≥n de crear la arquitectura perfecta desde el d√≠a uno. Pero el dise√±o prematuro es tan da√±ino como la falta de dise√±o.

Si el coste de arreglarlo en el futuro es el mismo que hacerlo ahora, posp√≥n la decisi√≥n.

Usa principios como SRP y TRUE para escribir c√≥digo que sea tolerante al cambio, no c√≥digo que intente adivinar el futuro.

El camino hacia un software mantenible empieza por reconocer que las aplicaciones no son est√°ticas. Son conversaciones vivas entre objetos.

![el-diseno-no-es-arte-es-supervivencia.webp](/images/blog/el-diseno-no-es-arte-es-supervivencia.webp)